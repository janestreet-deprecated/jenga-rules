open Core
open Import

module Alias = struct
  include Alias
  let default ~dir = Alias.create ~dir "DEFAULT"
end

(* try new coding style: pass the current [dir] via functor arg *)
module F(X : sig val dir : Path.t end) = struct
  open X

  let makefile_basename = "Makefile.extracted-from-jenga"

  let keep path =
    Path.basename path <> makefile_basename (* avoid sillyness *)
    && (
      Path.is_descendant ~dir path
      || Path.is_descendant ~dir:(Path.root_relative ".liblinks") path
      || Path.is_descendant ~dir:(Path.root_relative ".ppx") path
    )


  module Was_in_jenga_exe = struct
    let escape_newlines_for_make s =
      if not (String.contains s '\n') then s else
        let s =
          String.concat_map s ~f:(function
          | '\n' -> "\\n"
          | '\\' -> "\\\\"
          | c -> String.make 1 c)
        in
        sprintf "bash -c \"$(echo -e %s)\"" (quote s)

    let escape_dollars_for_make s =
      if not (String.contains s '$') then s else
        String.concat_map s ~f:(function
        | '$' -> "$$"
        | c -> String.make 1 c)

    let string_for_one_line_make_recipe_ignoring_dir action =
      let s = Reflected.Action.to_sh_ignoring_dir action in
      let s = escape_newlines_for_make s in
      let s = escape_dollars_for_make s in
      s
  end

  let wrap_relative_cd_from path s =
    if Path.(=) dir path then s else
      let relative_cd = Path.reach_from ~dir path in
      sprintf !"(mkdir -p %{quote}; cd %{quote}; %s)" relative_cd relative_cd s

  let format_path_as_make_target_or_dep = Path.reach_from ~dir
  let format_path_for_make_action path = Path.reach_from ~dir path
  let format_paths xs =
    String.concat ~sep:" " (List.map xs ~f:format_path_as_make_target_or_dep)

  let format_trip {Reflected.Trip.deps;targets;action} =
    let deps = List.filter deps ~f:keep in
    let targets = List.filter targets ~f:keep in
    let action_string =
      wrap_relative_cd_from (Reflected.Action.dir action)
        (Was_in_jenga_exe.string_for_one_line_make_recipe_ignoring_dir action)
    in
    match targets with
    | [] -> sprintf "#rule with no targets!"
    | t1::rest ->
      let touch_string =
        match rest with | [] -> "" | _ ->
          sprintf "\n\ttouch %s"
            (String.concat ~sep:" " (List.map rest ~f:format_path_for_make_action))
      in
      String.concat (List.map rest ~f:(fun target ->
        sprintf "%s : %s\n"
          (format_path_as_make_target_or_dep target)
          (format_path_as_make_target_or_dep t1)
      )) ^ sprintf "%s : %s\n\t%s%s"
             (format_path_as_make_target_or_dep t1) (format_paths deps)
             action_string touch_string


  let banner = "
# This Makefile was generated by jenga.

# Note: make doesn't properly support multi-target rules, so we do the best we can.
# The makefile should work when building from clean, and incremental builds, following
# source files changes. Incremental builds following selected removal of generated files
# is likely to fail.
"

  let format_putenv xs =
    String.concat (List.filter_map xs ~f:(fun (k, v_opt) ->
      (* There is no way to unset variable in makefiles, at least not at the version we
         have. Setting to the empty string doesn't work with at least OCAMLPARAM. So we
         just drop them. *)
      Option.map v_opt ~f:(fun v -> sprintf "export %s := %s\n" k v)))

  let start_all =
    sprintf "
.PHONY: start all
start:\n\tcd \"$$(pwd -P)\" && $(MAKE) all # cd to physical path
"

  (* not suitable for comparison in general, since it equates too many things *)
  let compare_trip_for_sort =
    (* Trying to compare in a way that equates path/lib__Foo and path/foo. We can just
       compare paths when we don't care about comparing packing vs wrapping anymore.*)
    let normalize_basename s =
      match String.substr_index s ~pattern:"__" with
      | None -> s
      | Some i -> String.uncapitalize (String.drop_prefix s (i + 2))
    in
    let key_of_trip (trip : Reflected.Trip.t) =
      List.map trip.targets ~f:(fun p ->
        Path.to_string (Path.dirname p), normalize_basename (Path.basename p))
    in
    fun trip1 trip2 ->
      [%compare: (string * string) list]
        (key_of_trip trip1)
        (key_of_trip trip2)
  ;;

  let format_makefile ~putenv ~roots trips =
    let trips = List.sort trips ~compare:compare_trip_for_sort in
    sprintf "%s\n%s\n%s\nall : %s\n\n%s\n"
      banner
      (format_putenv putenv)
      start_all
      (format_paths roots)
      (String.concat ~sep:"\n\n" (List.map trips ~f:format_trip))

  let rule =
    let makefile = relative ~dir makefile_basename in
    [
      Rule.create ~targets:[makefile] (
        Reflect.putenv *>>= fun putenv ->
        Reflect.alias (Alias.default ~dir) *>>= fun roots ->
        let roots = List.filter roots ~f:(fun r -> Path.(<>) r makefile) in
        Reflect.reachable ~keep roots *>>| fun trips ->
        Action.save (format_makefile ~putenv ~roots trips) ~target:makefile
      );
      (*Rule.default ~dir [Dep.path makefile];*)
    ]

  module Boot = struct

    let makefile_basename = "Makefile"
    let source_list_basename = "source.list"
    let tarball_basename = "tarball.tgz"

    let get_sources_from_trips ~roots trips =
      let deps =
        Path.Set.of_list (
          roots @ List.concat_map trips ~f:(fun trip -> trip.Reflected.Trip.deps))
      in
      let targets =
        Path.Set.of_list (
          List.concat_map trips ~f:(fun trip -> trip.Reflected.Trip.targets))
      in
      let sources = Path.Set.diff deps targets in
      Path.Set.to_list sources

    let format_source_list xs =
      String.concat (List.map xs ~f:(sprintf !"%{Path}\n"))

    let scheme ~targets:roots ~extraction_dir =
      let makefile = relative ~dir:extraction_dir makefile_basename in
      let source_list = relative ~dir:extraction_dir source_list_basename in
      let tarball = relative ~dir:extraction_dir tarball_basename in
      Scheme.dep (
        Reflect.putenv *>>= fun putenv ->
        Reflect.reachable ~keep roots *>>| fun trips ->
        Scheme.rules [
          Rule.create ~targets:[source_list] (return (
            Action.save (format_source_list (get_sources_from_trips ~roots trips)) ~target:source_list
          ));
          Rule.create ~targets:[makefile] (return (
            Action.save (format_makefile ~putenv ~roots trips) ~target:makefile
          ));
          Rule.create ~targets:[tarball] (
            Dep.all_unit [
              Dep.all_unit[Dep.path makefile; Dep.path source_list]
            ] *>>| fun () ->
            (* The [grep -v] avoids packing absolute files into the tarball. These are
               assumed to exist already at the remote site.

               In a similar way, the extracted [Makefile] contains calls to [bash] which
               must exist at the remote site.

               We dont have CR-stripping logic here because we intend that the boot rule
               will be run on sources pulled from the public release. *)
            bashf ~dir:extraction_dir
              !"tar czf %{quote} %{quote} -C %{quote} $(cat %{quote} | grep -v '^/' )"
              (Path.basename tarball)
              (Path.basename makefile)
              (Path.reach_from ~dir:extraction_dir dir)
              (Path.basename source_list)
          );
          Rule.default ~dir:extraction_dir [Dep.path tarball];
        ])

  end

end

let extract ~dir =
  let module M = F (struct let dir = dir end) in
  M.rule

let boot ~targets ~dir =
  let module M = F (struct let dir = Path.the_root end) in
  M.Boot.scheme ~targets ~extraction_dir:dir
